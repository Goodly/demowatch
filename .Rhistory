}
}
my_kmeans <- function(X, k) {
initial_centroids <- as.matrix(X[sample(nrow(X), k), ])
sq_distances <- matrix(0, nrow = nrow(X), ncol = k)
colnames(sq_distances) <- paste0("k_", 1:k)
convergent <- FALSE
while (convergent == FALSE) {
# calculate distances from observations to each cluster centroid
for (i in 1:k) {
sq_distances[, i] <-
apply(X,
1,
function(x) {sq_distance(initial_centroids[i, ], x)})
}
# find which cluster centroid each observation is closest to
assigments <- apply(sq_distances, 1, which.min)
# calculate new centroid positions
new_centroids <- matrix(0, nrow = k, ncol = ncol(X))
for (i in 1:k) {
cluster_obs <- X[assignments == i, ]
num_elements <- nrow(cluster_obs)
new_centroids[i, ] <- colSums(cluster_obs)/num_elements
}
# check if the centroids are converging
if (isTRUE(all.equal(round(initial_centroids, digits = 3),
round(new_centroids, digits = 3)))) {
convergent <- TRUE
} else {
initial_centroids <- new_centroids
}
}
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[assignments == k, ]
})
}
X <- iris[, 1:4]
my_kmeans(X, k = 3)
my_kmeans <- function(X, k) {
initial_centroids <- as.matrix(X[sample(nrow(X), k), ])
sq_distances <- matrix(0, nrow = nrow(X), ncol = k)
colnames(sq_distances) <- paste0("k_", 1:k)
convergent <- FALSE
while (convergent == FALSE) {
# calculate distances from observations to each cluster centroid
for (i in 1:k) {
sq_distances[, i] <-
apply(X,
1,
function(x) {sq_distance(initial_centroids[i, ], x)})
}
# find which cluster centroid each observation is closest to
assignments <- apply(sq_distances, 1, which.min)
# calculate new centroid positions
new_centroids <- matrix(0, nrow = k, ncol = ncol(X))
for (i in 1:k) {
cluster_obs <- X[assignments == i, ]
num_elements <- nrow(cluster_obs)
new_centroids[i, ] <- colSums(cluster_obs)/num_elements
}
# check if the centroids are converging
if (isTRUE(all.equal(round(initial_centroids, digits = 3),
round(new_centroids, digits = 3)))) {
convergent <- TRUE
} else {
initial_centroids <- new_centroids
}
}
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[assignments == k, ]
})
}
my_kmeans(X, k = 3)
initial_centroids <- as.matrix(X[sample(nrow(X), k), ])
sq_distances <- matrix(0, nrow = nrow(X), ncol = k)
colnames(sq_distances) <- paste0("k_", 1:k)
convergent <- FALSE
while (convergent == FALSE) {
# calculate distances from observations to each cluster centroid
for (i in 1:k) {
sq_distances[, i] <-
apply(X,
1,
function(x) {sq_distance(initial_centroids[i, ], x)})
}
# find which cluster centroid each observation is closest to
assignments <- apply(sq_distances, 1, which.min)
# calculate new centroid positions
new_centroids <- matrix(0, nrow = k, ncol = ncol(X))
for (i in 1:k) {
cluster_obs <- X[assignments == i, ]
num_elements <- nrow(cluster_obs)
new_centroids[i, ] <- colSums(cluster_obs)/num_elements
}
# check if the centroids are converging
if (isTRUE(all.equal(round(initial_centroids, digits = 3),
round(new_centroids, digits = 3)))) {
convergent <- TRUE
} else {
initial_centroids <- new_centroids
}
}
cluster_obs <- X[assignments == k, ]
View(cluster_obs)
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)
})
})
# find which cluster centroid each observation is closest to
clustering_vector <- apply(sq_distances, 1, which.min)
cluster_obs <- X[clustering_vector == k, ]
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)
})
})
View(X)
View(wss_cluster)
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)
return(sum(sum_of_squares_vector))
})
})
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)
sum(sum_of_squares_vector)
})
})
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)})
return(sum(sum_of_squares_vector))
})
?kmeans
kmeans_output <- kmeans(X, 3)
View(kmeans_output)
tss <- sum(apply(X, 1, function(x) {sq_distance(x, colMeans(X))}))
cluster_sizes <- table(clustering_vector)
cluster_sizes <- c(table(clustering_vector))
cluster_sizes
cluster_means <- new_centroids
View(cluster_means)
my_kmeans <- function(X, k) {
initial_centroids <- as.matrix(X[sample(nrow(X), k), ])
sq_distances <- matrix(0, nrow = nrow(X), ncol = k)
colnames(sq_distances) <- paste0("k_", 1:k)
convergent <- FALSE
while (convergent == FALSE) {
# calculate distances from observations to each cluster centroid
for (i in 1:k) {
sq_distances[, i] <-
apply(X,
1,
function(x) {sq_distance(initial_centroids[i, ], x)})
}
# find which cluster centroid each observation is closest to
clustering_vector <- apply(sq_distances, 1, which.min)
# calculate new centroid positions
new_centroids <- matrix(0, nrow = k, ncol = ncol(X))
for (i in 1:k) {
cluster_obs <- X[clustering_vector == i, ]
num_elements <- nrow(cluster_obs)
new_centroids[i, ] <- colSums(cluster_obs)/num_elements
}
# check if the centroids are converging
if (isTRUE(all.equal(round(initial_centroids, digits = 3),
round(new_centroids, digits = 3)))) {
convergent <- TRUE
} else {
initial_centroids <- new_centroids
}
}
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)})
return(sum(sum_of_squares_vector))
})
tss <- sum(apply(X, 1, function(x) {sq_distance(x, colMeans(X))}))
bss <- tss - sum(wss_cluster)
bss_over_tss <- bss/tss
cluster_sizes <- c(table(clustering_vector))
cluster_means <- new_centroids
return(list(cluster_sizes,
cluster_means,
clustering_vector,
wss_cluster,
bss_over_tss))
}
X <- iris[, 1:4]
my_kmeans(X, k = 3)
my_kmeans <- function(X, k) {
initial_centroids <- as.matrix(X[sample(nrow(X), k), ])
sq_distances <- matrix(0, nrow = nrow(X), ncol = k)
colnames(sq_distances) <- paste0("k_", 1:k)
convergent <- FALSE
while (convergent == FALSE) {
# calculate distances from observations to each cluster centroid
for (i in 1:k) {
sq_distances[, i] <-
apply(X,
1,
function(x) {sq_distance(initial_centroids[i, ], x)})
}
# find which cluster centroid each observation is closest to
clustering_vector <- apply(sq_distances, 1, which.min)
# calculate new centroid positions
new_centroids <- matrix(0, nrow = k, ncol = ncol(X))
for (i in 1:k) {
cluster_obs <- X[clustering_vector == i, ]
num_elements <- nrow(cluster_obs)
new_centroids[i, ] <- colSums(cluster_obs)/num_elements
}
# check if the centroids are converging
if (isTRUE(all.equal(round(initial_centroids, digits = 3),
round(new_centroids, digits = 3)))) {
convergent <- TRUE
} else {
initial_centroids <- new_centroids
}
}
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)})
return(sum(sum_of_squares_vector))
})
tss <- sum(apply(X, 1, function(x) {sq_distance(x, colMeans(X))}))
bss <- tss - sum(wss_cluster)
return(list(cluster_sizes = c(table(clustering_vector)),
cluster_means = new_centroids,
clustering_vector = clustering_vector,
wss_cluster = wss_cluster,
bss_over_tss = bss/tss))
}
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans <- function(X, k) {
initial_centroids <- as.matrix(X[sample(nrow(X), k), ])
sq_distances <- matrix(0, nrow = nrow(X), ncol = k)
colnames(sq_distances) <- paste0("k_", 1:k)
convergent <- FALSE
while (convergent == FALSE) {
# calculate distances from observations to each cluster centroid
for (i in 1:k) {
sq_distances[, i] <-
apply(X,
1,
function(x) {sq_distance(initial_centroids[i, ], x)})
}
# find which cluster centroid each observation is closest to
clustering_vector <- apply(sq_distances, 1, which.min)
# calculate new centroid positions
new_centroids <- matrix(0, nrow = k, ncol = ncol(X))
for (i in 1:k) {
cluster_obs <- X[clustering_vector == i, ]
num_elements <- nrow(cluster_obs)
new_centroids[i, ] <- colSums(cluster_obs)/num_elements
}
# check if the centroids are converging
if (isTRUE(all.equal(round(initial_centroids, digits = 3),
round(new_centroids, digits = 3)))) {
convergent <- TRUE
} else {
initial_centroids <- new_centroids
}
}
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)})
return(sum(sum_of_squares_vector))
})
tss <- sum(apply(X, 1, function(x) {sq_distance(x, colMeans(X))}))
bss <- tss - sum(wss_cluster)
return(list(cluster_sizes = c(table(clustering_vector)),
cluster_means = new_centroids,
clustering_vector = clustering_vector,
wss_cluster = wss_cluster,
bss_over_tss = bss/tss))
}
my_kmeans <- function(X, k) {
initial_centroids <- as.matrix(X[sample(nrow(X), k), ])
sq_distances <- matrix(0, nrow = nrow(X), ncol = k)
colnames(sq_distances) <- paste0("k_", 1:k)
convergent <- FALSE
while (convergent == FALSE) {
# calculate distances from observations to each cluster centroid
for (i in 1:k) {
sq_distances[, i] <-
apply(X,
1,
function(x) {sq_distance(initial_centroids[i, ], x)})
}
# find which cluster centroid each observation is closest to
clustering_vector <- apply(sq_distances, 1, which.min)
# calculate new centroid positions
new_centroids <- matrix(0, nrow = k, ncol = ncol(X))
for (i in 1:k) {
cluster_obs <- X[clustering_vector == i, ]
num_elements <- nrow(cluster_obs)
new_centroids[i, ] <- colSums(cluster_obs)/num_elements
}
# check if the centroids are converging
if (isTRUE(all.equal(round(initial_centroids, digits = 3),
round(new_centroids, digits = 3)))) {
convergent <- TRUE
} else {
initial_centroids <- new_centroids
}
}
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)})
return(sum(sum_of_squares_vector))
})
tss <- sum(apply(X, 1, function(x) {sq_distance(x, colMeans(X))}))
bss <- tss - sum(wss_cluster)
return(list(cluster_sizes = c(table(clustering_vector)),
cluster_means = new_centroids,
clustering_vector = clustering_vector,
wss_cluster = wss_cluster,
bss_over_tss = bss/tss))
}
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
my_kmeans(X, k = 3)
set.seed(1)
X <- iris[, 1:4]
my_kmeans(X, k = 3)
set.seed(2)
X <- iris[, 1:4]
my_kmeans(X, k = 3)
set.seed(3)
X <- iris[, 1:4]
my_kmeans(X, k = 3)
set.seed(4)
X <- iris[, 1:4]
my_kmeans(X, k = 3)
set.seed(4)
X <- iris[, 1:4]
my_kmeans(X, k = 3)
kmeans(X, 3)
set.seed(4)
kmeans(X, 3)
?hclust
dist(X)
dissimilarity <- dist(X)
hclust(dissimilarity, "complete")
hc.complete <- hclust(dissimilarity, "complete")
plot(hc.complete)
?cutree
cutree(hc.complete, k = 3)
View(iris)
iris[, 5]
as.numeric(iris[, 5])
clustering_accuracy <- mean(cutree(hc.complete, k = 3) == as.numeric(iris[, 5]))
?hclust
# complete linkage
hc.average <- hclust(dissimilarity, "average")
plot(hc.average)
plot(hc.average)
# complete linkage clustering accuracy
mean(cutree(hc.average, k = 3) == as.numeric(iris[, 5]))
# complete linkage
hc.single <- hclust(dissimilarity, "single")
plot(hc.single)
# complete linkage clustering accuracy
mean(cutree(hc.single, k = 3) == as.numeric(iris[, 5]))
knitr::opts_chunk$set(echo = TRUE)
dissimilarity <- dist(X)
knitr::opts_chunk$set(echo = TRUE)
# will be using the `iris` dataset as a way to test my function
data("iris")
sq_distance <- function(vec1, vec2) {
sum_of_squares <- sum((vec1 - vec2)^2)
return(sum_of_squares)
}
my_kmeans <- function(X, k) {
initial_centroids <- as.matrix(X[sample(nrow(X), k), ])
sq_distances <- matrix(0, nrow = nrow(X), ncol = k)
colnames(sq_distances) <- paste0("k_", 1:k)
convergent <- FALSE
while (convergent == FALSE) {
# calculate distances from observations to each cluster centroid
for (i in 1:k) {
sq_distances[, i] <-
apply(X,
1,
function(x) {sq_distance(initial_centroids[i, ], x)})
}
# find which cluster centroid each observation is closest to
clustering_vector <- apply(sq_distances, 1, which.min)
# calculate new centroid positions
new_centroids <- matrix(0, nrow = k, ncol = ncol(X))
for (i in 1:k) {
cluster_obs <- X[clustering_vector == i, ]
num_elements <- nrow(cluster_obs)
new_centroids[i, ] <- colSums(cluster_obs)/num_elements
}
# check if the centroids are converging
if (isTRUE(all.equal(round(initial_centroids, digits = 3),
round(new_centroids, digits = 3)))) {
convergent <- TRUE
} else {
initial_centroids <- new_centroids
}
}
# calculating return objects
wss_cluster <- sapply(1:k, function(k) {
cluster_obs <- X[clustering_vector == k, ]
sum_of_squares_vector <- apply(cluster_obs, 1, function(x) {
sq_distance(new_centroids[k, ], x)})
return(sum(sum_of_squares_vector))
})
tss <- sum(apply(X, 1, function(x) {sq_distance(x, colMeans(X))}))
bss <- tss - sum(wss_cluster)
return(list(cluster_sizes = c(table(clustering_vector)),
cluster_means = new_centroids,
clustering_vector = clustering_vector,
wss_cluster = wss_cluster,
bss_over_tss = bss/tss))
}
set.seed(5)
X <- iris[, 1:4]
my_kmeans(X, k = 3)
set.seed(5)
kmeans(X, 3)
dissimilarity <- dist(X)
# complete linkage
hc.complete <- hclust(dissimilarity, "complete")
plot(hc.complete)
# complete linkage clustering accuracy
mean(cutree(hc.complete, k = 3) == as.numeric(iris[, 5]))
# complete linkage
hc.average <- hclust(dissimilarity, "average")
plot(hc.average)
# complete linkage clustering accuracy
mean(cutree(hc.average, k = 3) == as.numeric(iris[, 5]))
# complete linkage
hc.single <- hclust(dissimilarity, "single")
plot(hc.single)
# complete linkage clustering accuracy
mean(cutree(hc.single, k = 3) == as.numeric(iris[, 5]))
setwd("~/Desktop/spring-2018/repos")
dat <- read_csv("test_data.csv")
library(readr)
dat <- read_csv("test_data.csv")
setwd("~/Desktop/spring-2018/repos/df-canonalization")
setwd("~/Desktop/spring-2018/repos/df-canonicalization")
dat <- read_csv("test_data.csv")
dat <- read_csv("data/test_data.csv")
View(dat)
colnames(dat)
dat$`metadata/city`
dat$`highlight_tasks/0/highlight_taskruns/0/highlights/0/offsets/4/0`
